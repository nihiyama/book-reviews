# WebAPIの設計を読んで

Arnaud Lauret. [Web APIの設計](https://www.amazon.co.jp/Web-API%E3%81%AE%E8%A8%AD%E8%A8%88-Arnaud-Lauret-ebook/dp/B08CK2H12H/) (Japanese Edition)

## 参考図書

本書で公式に書かれていないが、個人的に「あ、これ進研ゼミでやったやつだ」となった本

- [Web API The Good Parts](https://www.oreilly.co.jp/books/9784873116860/)
- [Site Reliability Workbook](https://www.oreilly.co.jp/books/9784873119137/)
- [マイクロサービスパターン](https://www.amazon.co.jp/%E3%83%9E%E3%82%A4%E3%82%AF%E3%83%AD%E3%82%B5%E3%83%BC%E3%83%93%E3%82%B9%E3%83%91%E3%82%BF%E3%83%BC%E3%83%B3-%E5%AE%9F%E8%B7%B5%E7%9A%84%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89%E8%A7%A3%E8%AA%AC-impress-top-gear/dp/4295008583/)
- [ジョブ理論](https://www.amazon.co.jp/%E3%82%B8%E3%83%A7%E3%83%96%E7%90%86%E8%AB%96-%E3%82%A4%E3%83%8E%E3%83%99%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BA%88%E6%B8%AC%E5%8F%AF%E8%83%BD%E3%81%AB%E3%81%99%E3%82%8B%E6%B6%88%E8%B2%BB%E3%81%AE%E3%83%A1%E3%82%AB%E3%83%8B%E3%82%BA%E3%83%A0-%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E3%83%AA%E3%83%BC%E3%83%80%E3%83%BC1%E4%B8%87%E4%BA%BA%E3%81%8C%E9%81%B8%E3%81%B6%E3%83%99%E3%82%B9%E3%83%88%E3%83%93%E3%82%B8%E3%83%8D%E3%82%B9%E6%9B%B8%E3%83%88%E3%83%83%E3%83%97%E3%83%9D%E3%82%A4%E3%83%B3%E3%83%88%E5%A4%A7%E8%B3%9E%E7%AC%AC2%E4%BD%8D-%E3%83%8F%E3%83%BC%E3%83%91%E3%83%BC%E3%82%B3%E3%83%AA%E3%83%B3%E3%82%BA%E3%83%BB%E3%83%8E%E3%83%B3%E3%83%95%E3%82%A3%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3-%E3%82%AF%E3%83%AA%E3%82%B9%E3%83%86%E3%83%B3%E3%82%BB%E3%83%B3/dp/4596551227)
- [ソフトウェアアーキテクチャの基礎](https://www.oreilly.co.jp/books/9784873119823/)
- [OAuth徹底入門](https://www.amazon.co.jp/OAuth%E5%BE%B9%E5%BA%95%E5%85%A5%E9%96%80-%E3%82%BB%E3%82%AD%E3%83%A5%E3%82%A2%E3%81%AA%E8%AA%8D%E5%8F%AF%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%92%E9%81%A9%E7%94%A8%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E5%8E%9F%E5%89%87%E3%81%A8%E5%AE%9F%E8%B7%B5-Justin-Richer/dp/4798159298)
- [Real World HTTP 第2版](https://www.oreilly.co.jp/books/9784873119038/)
- [Webを支える技術](https://www.amazon.co.jp/Web%E3%82%92%E6%94%AF%E3%81%88%E3%82%8B%E6%8A%80%E8%A1%93-HTTP%E3%80%81URI%E3%80%81HTML%E3%80%81%E3%81%9D%E3%81%97%E3%81%A6REST-WEB-PRESS-plus/dp/4774142042/)

## この本をおすすめする人

- Web API The Good Partsを読んで次のWeb APIの本を探している人
  - Web API The Good Partsとは切り口が違うのでいいと思った。（APIの設計、それを取り巻く環境）
- APIを設計・構築したことがあり、悩んでいる人
  - 著者自身がかなり悩んできたんだろうなというのが本書からとても感じる。先人の悩みに触れてベストプラクティスを抽出できると思った。
  - ソフトウェアはトレードオフである。本書もトレードオフによる選択が随所に出てくる。設計・構築したことがない人はこうしたトレードオフについての勘所が全くないと思われるので、逆に全ての情報を鵜呑みにしてしまい、危険ではないかと感じた（ちょっと強めに言いすぎてるかも）

## この本をおすすめしない人

- API関連の書籍を一度も呼んだことがない人
  - 前提知識がないとある程度のスピードで読めずに挫折してしまうと思った。
  - APIとして当たり前の知識がないと本書のプラクティスを体系的に理解できないと思った
- 趣味レベルでもAPIを構築・設計したことがない人
  - 趣味レベルでもAPIにふれていないと本書のプラクティスが刺さらないと思った。

## 感想

本書「Web APIの設計」は、APIの設計・構築に悩む中級者以上の方々に対してすごく刺さるものがあると感じた。そして、そういった方々にとてもおすすめしたい一冊である。

Web APIの書籍としては「Web API The Good Parts」が有名であり、多くの人が入門書として読まれていることと思う。「Web API The Good Parts」は2014年に発行されていながらも完成度がかなり高く（そして量が少なく簡潔）、約10年ほどたったいまでも、色褪せない情報として利用できる。（いい意味でWeb APIは枯れた技術であるし、それをちゃんと伝えたこの本はすごい。。）。本書を読んだが、Web APIの最初の一冊としてはやはり「Web API The Good Parts」をおすすめする。

本書はこれからWeb APIを学ぶための最初の本ではない。少なくとも「Web API The Good Parts」と「Real World HTTP 第2版」（などのWeb, HTTPについて書かれた書籍）を読み、読者自身がWebシステム（とAPI）を設計・構築しないとうまく吸収できない本だと感じた。理由を以下に述べる。

- 本のタイトルの通り設計がメインであり、そのほとんどがコンシューマを意識した設計のプラクティスである（コンシューマ目線はすごくいい！）
  - プロバイダ目線じゃなくてコンシューマ目線でいこうねと言うテイストで書かれている
  - 初学者はプロバイダとしての知識がないのであまり理解ができない（と思われる）
- 専門的な知識についての説明が少ない
  - HTTP, Web APIの基本的なところは別の書籍の方が詳しい
  - 割と文章が長ったらしいところが多いので専門知識を知らない状態だと、読むのに疲弊する

ここまでの感想を読むと、最初におすすめしておきながらほんとにいい本なのか？と感じる人がいるかもしれない。「Web API The Good Parts」を推しすぎだろ！と。  
まず、Web APIをこれから手っ取り早く学んでベストプラクティスを踏襲したい人は必ず「Web API The Good Parts」買ってほしい。これはガイドラインになるし手頃なハンドブックとして使える。（というかこう言う本を読まずになにも理解していない状態でWeb APIをリリースするな）  
本書は「Web API The Good Parts」と全く切り口が違う。（一般的な）ベストプラクティスのその先を目指したい人に向いていると思う。私は本書を読んで随所で以下を感じていた。

- ここまで考慮して設計していなかったな（気づかせてくれてありがとう）
- このレベル・視点の悩みを持っていなかった。（気づかせてくれてありがとう）
- ここまでコンシューマーを意識できていなかった。（気づかせてくれてありがとう）
- これからこの悩みに陥る可能性があるな。（気づかせてくれてありがとう）

本書についてのレビューが書かれているサイトについてもいくつか見たが、中には分かりにくいというものがあった。たしかに、長ったらしく書かれているところは多いと感じたが、本書の中で一貫して書き方（構成）は統一されているし、図がとても分かりやすいと感じた（そしてめちゃくちゃ参考になる）。

本書は割とボリューミーではあるが、読み飛ばしてもいいところも多い。第1部はさらッと読んでもいいと感じた。第2部、特に第3部はしっかり読むだけの価値はあると思う。（おそらくこの本を手に取る方々はそこに悩みがあるはずだし、他の書籍であまりWeb APIのこういったことについて見たことがないかも）  
また、上記にも書いたが、本書はコンシューマー目線なのがとても良い。だいたいプロバイダ目線となって沼に入ってるのではないだろうか？コンシューマーを意識した設計の「やり方」を本書で学ぶことができる。

さあ、[Web APIの設計](https://www.amazon.co.jp/Web-API%E3%81%AE%E8%A8%AD%E8%A8%88-Arnaud-Lauret-ebook/dp/B08CK2H12H/)を読んでみましょう。  
Web APIについて悩みを持った人たちで集まって輪読会をやっても面白いかもしれません。

---

以下は読書メモである。

## 第1部 APIデザインの基礎

> しっかりとした基礎がなければ、スキルやトピックがどれだけ高度であっても宝の持ち腐れ

> APIをユーザーの視点に立って検討する

- フロントエンド開発者（でありアプリを使うユーザー）
- APIを利用する様々なdeveloper

> APIは後悔するシステムではなく、ユーザーが自分の目標を簡単に達成できるようにするものの

> 記述にはREST API用の OASの様な適切なツールを使え

- コードからOpenAPIを生成してマークダウンにするのがいい気がしている

### 第1章 APIデザインとは何か

> Web APIは現代の「つながる世界（みんなAPI使ってやりとりしてる）」の大黒柱→設計の最大の関心事でなければならない

> 通常、APIは（1つではなく）多数のコンシューマによって利用されることを前提に開発されている。そのようにしておけば、そのつど何もかも作り直さずに済むからだ

- フロントエンドも単なるAPIのプロバイダーとしてもこれができるとかなりいい
- Web, ネイティブアプリ, ディベロッパーに提供しやすくなる
- セキュリティ、利便性の観点からプライベート、パブリックの分割はある

> パブリックとプライベートの分類は、APIがどのように提供されるかではなく、誰に対して提供されるかによって決まる

> 全体像をまったく顧みず、インターフェイスの両側（コンシューマ側とプロバイダ側）を考慮せず、原則を無視してAPIを設計すれば、大失敗に向かってまっしぐら

> APIの目的は、プログラミング部分が何であっても、人々がそれぞれの目標をできるだけ単純に達成できるようにすること

- 「単純に達成させる」が大事。ある目的を達成するために何回もAPIを叩いたり、ユーザー側で処理が必要になるのは良くない

### 第2章 ユーザーを意識したAPIを設計する

> APIはデータや機能をやみくもに提供するためのものではない。身近にあるユーザーインターフェイスと同様に、APIはそのユーザーがその目標、すなわちゴールを達成する手助けをするためのもの

- 常にユーザーについて考えることが大事
- といいつつ、内部の組織構造を意識したAPIができるというのをよく聞く（コンウェイ）

> 歴史に基づいて名前路つけたために、本来の目的が完全に隠れてしまっている

- ユーザーにとってはどうでもいいことは前面に出さない（最近のSaaSは名前がわかりやすいものが多いなぁ）
- 悪い意味でシステムへの愛着が湧くのもよくないと思う（ユーザービリティを高めるためのシステム回収が内部の人の思いが入ってうまくいかないことがある）

> APIを設計する時には以下の点に関する深く正確な知識が必要  
・そのAPIを使えるのは誰か  
・何ができるか  
・それをどのようにおこなうか  
・そのために何が必要か  
・何が返されるか  

> APIのさまざまな種類のユーザーを最初に洗い出しておけば、包括的なゴールリストを作るのが容易になる

> APIを提供している組織のコミュニケーション構造の影響を受けることがある

- ↑で書いたけど、やっぱりコンウェイでてきたな。。

> APIのゴールリストとデータが（その構造であろうと名前であろうと）データベースとあまりにも一致しているとしたら、そのAPIをプロバイダの視点に立って設計している可能性がある。その場合は、APIのユーザーがそうした詳細にアクセスできることが本当に妥当かどうかもう一度確認

- リソース型のAPIだと割とそれでもいいと思っている。（無駄な情報が入ってたりするのは良くないけど）
- ただユーザーがやりたいことのために2回あるAPIを叩かなければいけないとかはNG

>  内部のビジネスロジックを曝け出すようなAPIになっていないか注意が必要

- ユーザーにとって使いやすいAPIがこれのケースってこともあるし、結構むずかしいな。。
- プロバイダに危険がさらされる可能性もあるし、確かに注意は必要である
- 特にパブリックなAPIとして公開する場合
- 基本的にプライベートにつくりつつ、BFFとかAPI GWでフロント向け、パブリック向けみたいな感じの方がいいのかな？(作るのに時間はかかりそう)

> APIをプロバイダの視点に立って設計した場合、この人間組織と一致するゴールが公開されてしまう可能性がある

- 横断的に調整する係が必要？
- マイクロサービス、サイロ化されてると悲しい結果が待っていそう..

### 第3章 プログラミングインターフェイスを設計する

> リソースのパス（パスパラメータ）の唯一の要件は一意であることだが、明示的であることも望ましい

- 基本的にディレクトリ/ファイルのパス設計と変わらないと思ってるし、大体みんなそう言ってる

> パスはAPIのユーザーが簡単に解釈できるものでなければならないため、パスに含まれる情報は多ければ多いほどよい

- これはほんまにそれ
- リソース型のAPIだと割と簡単に名前が決まるが、問題はファンクション型
- ファンクション型で名前を短くしたり（そのせいで何をやるかわからない）、安易にgetみたいな名前をつけて、実はサイドエフェクト的に冪等性のない処理してると最悪

> レスポンスを設計する際、操作されたリソースをやみくもにマッピングするのは禁物である。コンテキストに応じてプロパティの削除や名前変更を行うことに加え、データ構造も調整しなければならない

- やみくもにマッピングしてしまっているところあるなぁ

> 設計者がRESTリソースでのアクションをHTTPメソッドにマッピングできない場合、最初の選択肢はたいていアクションリソースを作成することである

- これは簡単かつわりと協力(開発者としても利用者としても認知不可が下がる上に決定しやすい)
- ↑でたびたび言っているファンクション型のAPI=アクションリソース
- そういえば、ステータス更新のためのAPIを用意したこともあった（他のリソースを触らせたくなくて、ステータス更新だけをやらせたいケース）

> アクションリソースの呼び出しにはHTTPメソッドPOSTを使う

> APIスタイルの準拠とユーザーフレンドリ性の2軸はトレードオフになりがち（これはいたって普通）

- なるべく両方とも満たせる形に持っていきたい（平面にプロットした時に上の2軸にたいして45度かつノルムが大きい）
- あまり悩みすぎずに設計するのも大事

### 第4章 API記述フォーマットを使ってAPIを記述する

> OAS（OpenAPISpecification）は、プログラミング言語に依存しないRESTAPI記述フォーマットである

> ワードプロセッサやスプレッドシートを使う？バージョニングやマニュアル生成、API各種設定を考えてOAS一択。プロバイダだけでなくコンシューマも恩恵を受ける。

- この章はOASの説明だったので、特に感想はなし


## 第2部 ユーザブルなAPIの設計

> ユーザーブルでないAPIに価値はない

> コンシューマはAPIを使うときに頭を使いたくない。コンシューマが求めているのは目標を瞬時に達成できる単純明快な設計のAPIであり、データ、ゴール、エラーフィードバックを理解するために時間を無駄にしたくない。

- SRE本でもでてくる認知不可の話
- 自分が利用者だったとして認知不可上がるかどうかはちゃんと見た方がいい

### 第5章 単純明快なAPIを設計する

> 明確な名前にする

> 使いやすいデータ型フォーマットにする

> すぐ使えるデータにする
-
 パスパラメータの際の銀行口座のアカウントIDの例はUUIDの方がいい気がしている(盗み見もあるのでセンシティブなデータは気をつけたい←フロントエンドにそのまま使われそうなきがする)

> 明確な入力を要求する(わかりやすい名前づけ)

> エラーフィードバックを一つ残らず洗い出す

> 情報的価値のあるエラーフィードバックを返す

- まずはステータスコードで。あとメッセージはちゃんと書こう
- メッセージはサービスで統一感を出すために割と最後の方にやってる
- 403はシステムによって考えるところはあるかも。（権限の境目を見せたくないときとか→404にしておく）

> エラーを包括して返す（複数のエラーに引っかかる場合リストで返すとか）

- エラーはすぐに返したいからなぁ。。(プロバイダとしては)
- つまりエラーであったとしても全てのバリデーションは通せと言うことか...

> 情報的価値のあるフィードバックを返す

- これはエラーと同様。成功(2xx)についてもちゃんと決められたステータスコードで返す

> 明快なゴールフローを用意する

- ユーザーにたくさんの手続きをふませるようになっていないかなど考えておかないとね

> エラーを回避する

- エラーを回避するために（コンシューマーのための）フローを考える

> ゴールを集約する

- これはAPI GWで実装した方がいい気がする（ある程度大きなシステムだったら）

> ステートレスなフローを設計する

### 第6章 予測可能なAPIを設計する

> 一度も訪れたことのない建物でドアを開ける方法を知っているのはなぜだろうか。同じようなドアを前に開けたことがあるからだ

- 本当にこれ大事。ユーザーに学習コストなく利用してもらうという。。

> 一貫性のある設計

- 巨人の肩に乗ると言う表現が正しいかはわからないが、有名どころのAPIの設計と合わせる（真似をする）とかやっておくといいと思っている
- 一貫性のあるというのは、自システムだけではなくて世間一般のシステムと比べた時もおなじ
- つまり、いろんなシステム、サービスを常に見ておくのが大事だと思う

> 一貫性のあるデータを設計する→名前を選ぶところから始まる

- ほんとに名前の一貫性すらやってないのを見ると悲しくなる。。

> 一貫性のあるゴールを設計する

- エラーもそう
- 入力も。こっちはパスパラメータなのにこっちはクエリパラメータとかはだめ

> 一貫性の4つのレベル（これ、わかりやすい。。）  
・レベル1：APIの内部での一貫性  
・レベル2：組織、企業、チームのAPIにまたがる一貫性  
・レベル3：APIの問題領域での一貫性  
・レベル4：外の世界との一貫性  

> HTTPプロトコルルールを厳格に適用するだけで一貫性が得られる

- まずは基礎に従うのがほんとに大事

> APIの設計は、「APIデザインガイドライン」や「APIデザインスタイルガイド」と呼ばれるドキュメントのルールに従って正式に定義しなければならない。組織内のAPI設計者があなた1人しかいないとしても、そうしたガイドラインは重要である。なぜなら、私たちは時間が経つと以前に行ったことを（単純なAPIであっても）忘れてしまう傾向にあるからだ。

- 強い意志を持ってちゃんとつくらなきゃな。。そしてガイドラインがスタートライン。コードレビューなどを通して浸透させることも大事

> 自動翻訳はお勧めしない。結果はあまり正確ではないことがあり、コンシューマ／ユーザーフレンドリであることを目指すせっかくの試みが完全に台無しになることがある。

- ユーザーとして各種サイトでこれなってるとたしかに、使いたくないな。。と思ってしまう

> フィルタリング、ページング、ソート

- 大事。。ページングはやり方がいろいろあるけど、結局idベースで指定させるやり方しかやったことないかも..(ページ指定だと実際撮りたかったものがとれないケースとかあるよな。。)

### 第7章 うまく整理された簡潔なAPIを設計する

> データは重要なものを上から順に並べたり、グループ化して近くに配置する

- これはあまり気にしたことなかったのでやるようにしよう。。(グループ化は大事なきがする)
- 取得して得られたリソースの見やすさもだいじだな。。

> ユーザーに利用してもらいやすいようにゴールを整理する。OASのドキュメントにおいてもちゃんとカテゴリーごとに分ける。

- ソースコードから自動生成しているのでOASはあまり書いていない。つまりコード書くときにちゃんとカテゴリ化して作ることが大事

> やりたいことが多すぎるのが本当の問題であり、しかもそれほど便利には見えない。

- これは陥りがち。。「ジョブ理論」でも同じようなことが言われていた。

> データの深さは3を超えないように設計する（グループ化しろというのはあるが）

## 第3部 コンテキストに応じたAPIデザイン

> 以下の質問には全て答えられるようになっていなければならない。(APIを取り巻く全体像をちゃんと理解する)  
・APIに意図される機能とAPIがユーザーに提供される方法を考えた場合、私たちの設計はまったく安全であると言えるだろうか。  
・たとえば、あまり品質がよくない3Gネットワーク上で動作するモバイルアプリケーションでも実際に使えるだろうか。  
・私たちの設計はターゲットコンシューマにとって実際に最善の設計だろうか。  
・既存のシステムで実際に実装できるだろうか。  
・ドキュメントがいらないほどよい設計だろうか。  
・他のAPIとの一貫性が完全に保たれているだろうか。  
・本番稼働環境にデプロイ済みのAPIを更新したい場合、その作業は簡単だろうか。
  
> セキュア・バイ・デザインでなければならない

### 第8章

> 最小権限の原則。アクセス制御を可能にするためにAPIを分割する

- コンシューマに応じてアクセス可能なAPIを絞ることでセキュリティリスクを小さくできる
- 各々のユーザーのゴールが見えていれば割と簡単に実装はできそう

> 複雑だが、柔軟かつ細分化されたスコープを定義する

- エンドユーザー向けにスコープを選ばせることもあるので、このインターフェイスもちゃんと用意する必要がある

> ゴール→リソース（コンセプト）→リソース:CRUD→リソース:アクションの順に整理すると明確にしやすい

- この整理の仕方わかりやすいなぁ..

> 単純だが、それほど柔軟ではない大まかなスコープを定義する

- ↑とは逆ではあるが、トレードオフなので、自システムに合うように設計すればいい。

> カテゴリベースのスコープを定義するのは大抵よい考えではない

- これは陥りがち。。
- ゴールを考えてより良い分割を考える（これは大まかなスコープでも）
- 細分化だと認知不可上がるけど大まかに作るくらいがよさそう。（脳死で細分化って結局プロバイダ目線な気がする）

> まったく同じに見えるリクエストに対して異なるリターン
- これは良くやる。リストを返す系だと便利

> センシティブなデータについては何をセンシティブとみなすかをCISO, DPO, CDO, 法務部から聞け
- やらかしたあとで、わかりませんでしたとかは話にならない。。

> 以下の3つを使って制御（適宜組み合わせ）  
・専用のゴールを使う  
・スコープベース  
・パーミッションベース

> セキュアのエラーフィードバック

- 404を返すのもありという記載もあったけど他にもいろいろあるんだなぁ

### 第9章 APIの設計を進化させる

> APIは設計・構築したら終わりではない。ここからが勝負

> APIとその進化をどれほど慎重に設計したとしても、破壊的変更は避けられない。単に時間の問題である。

- これはちゃんと受け入れる
- いきなりちゃんとした設計はできないし、だからこそユーザーからのフィードバックも受けて常によくしていかなければいけない。
- 破壊的な変更があるときはv2を用意して並行運用とった方がいいだろということがおおいなぁ。。

> 出力データを変更する最も安全な方法は、純粋かつ単純に新しい要素を追加すること

- 変更するなら新しいのを追加して後方互換性を保つ
- 被るけどこちらの方が安全
- DBも同じアプローチだと安全（大体次の次のリリースで消すとかしてる）

> プロパティを削除せずにnullを返す

- これはDBも同じで安易にカラムを削除しない方がいい

> 入力の安全な変更はプロパティの追加のみ

- それはそう
- おなじパラメータ（どっちかつ買ってもいいけど片方はdepricated）を用意する戦略、Terraformとかだと良く見るけど、WebAPIだとなじみないな。。

> ハイラムの法則：APIに十分な数のユーザーがいれば、コントラクトで何を約束するかは問題ではない。システムの目に見える振る舞いはすべて誰かに依存することになる

- APIを公開する(APIじゃなくても公開する)ということはこういうことなんだよなぁ。。
- 誰かに依存するのでちゃんと防御してつくるのは大事

> 後方互換性がなくなったらAPIのバージョン変更になる

> ここら辺はセマンティックバージョニングとかと合わせて考えるといい（書いてた。気づき、大体そのあと数ページ後くらいに出てくる）

> 「破壊的変更かどうか」を意識する。インターフェイスに出ることもあるが、見えないコントラクトの変更ということもある。常にコンシューマの視点にたって考える

> バージョニングの方法

- ドメイン
- パス（これが一番なじみある）
- クエリパラメータ(おすすめしない。機能とバージョニングが混在する)
- カスタムヘッダ（これ、ユーザーはあまり使わないよね。（つまりユーザーフレンドリーではない））
- コンテントネゴシエーション（これもユーザーフレンドリーではない）
- コンシューマの設定（例えばトークン払い出し時に決まるとか）

> リリースノートは常に提供されなければならないが、必要なときに利用できるとは限らない。そして、リリースノートをまったく読まない人もいる。

- 読まない人もいる（そしてそれがほとんど）と言うことをちゃんと理解する。。

> RESTAPIの世界では、最も一般的な戦略はAPIレベルのバージョニング

- リソースやデータ、アクションなどでもできそうであるが、どれもユーザーフレンドリーではないし、そもそもREST APIのベストプラクティスではない

> 拡張可能にする

- 安易なbool値ではステータス管理ではなく、statusプロパティを用意して文字列で管理する
- なんか昔のシステムでは全部文字列型にしてたのを見たことがあるけどそう言うことではないよ。。
- 同じようなデータはリストにまとめる。（イベント系とか）

> 自分が行うことには保守的に、他人から受け取るものには寛容に(ポステルの法則)

- なるほど

> APIが大きくなればなるほど、進化の数が増え、ひいては破壊的変更のリスクが高くなる。非常に単純な理屈であり、解決策は明白だ。大きなAPIを構築する代わりに、より小さなAPIを構築すべきなのだ。

- なるべく小さく作るように心がける

### 第10章 ネットワーク効率のよいAPIを設計する

> HTTPベースのAPIでは、ごく一般的な最適化として、圧縮の有効化と持続的接続の有効化の2つがある

- KeepAliveとgzipかな

> APIの設計者にとって重要なのは、ネットワーク通信のパフォーマンス問題への対処として既存の設計を修正する前に、そうした最適化が検討されたかどうかをAPIチームに確認することである

- こういうのをちゃんと検討できるように働きかけをしたい

> HTTPプロトコルキャッシュの利用

- 有効期限の調整とか、キャッシュがあるがゆえにバグが出るとかもあるので難しいところではあるよなぁ
- コンシューマのゴールを考えて設計する

> ページングを利用したデータの削減

- ネットワークのコスト削減という点においても効果的

> リソース展開可能にする（クエリパラメータで展開するかどうかを指定して制御）

- これは割と良くみる(verbose=trueみたいな方法とかでも)

> GraphQLの選択

- ネットワーク効率の話でこれが出てきたのは初めて見た

### 第11章 コンテキストに基づいてAPIを設計する

> 時間のかかる処理に対処する

- 簡単には非同期だよね（簡単？選択としては簡単。実装はいろいろ考えなきゃ。。）
- アウトボックスパターンを採用してよくやってる

> コンシューマへの通知
> ・ポーリング
> ・Webフック

- SaaS通しだとWebフックはあり。WebアプリケーションだとWebSocketのやりかた(双方向通信)がいいと思っている
- ポーリングは場合によってはあり。実装はめちゃくちゃ簡単なので。
  - 通信がシビアでなかったり、状態更新くらいの軽い処理だったら利用している。（クライアントから仕掛けた方が楽だし）

> SSEを利用する

- SSEは結局HTTPでの長く接続する必要があるので、採用したことないな。。

> WebSocketを利用する

> 複数の要素を更新する→PATCHを使う

- 複数の要素の更新、あまり用意したことなかったな。。
- 207使って返すのか、勉強になる

> 郷に入れば、郷に従え

- 業界によってなじみのあるインターフィエスがあるので、それに対応するようにAPIを作るということも重要
  - とはいえ、標準化したい（してほしい）ところでもあるなぁ。。

### 第12章 APIを文書化する

> 大胆にもスプレッドシートを使う人までいる（お願いだからやめて!）

- ほんまにやめてくれ。。
- リファレンスマニュアルはOASからツールを使って自動生成しろ

> ゴールを文書化する

- 目的、何が必要か、リターンなどをちゃんと書く
- 目的はちゃんと書けてないので書きたい

> セキュリティを文書化する

- スコープについて書けてないので書きたい

> ・純粋にコードのみに基づいて生成したドキュメントは完全とは言い難く、推奨されない。  
・既存のアノテーションフレームワーク（少なくとも筆者が利用してきたもの）では、API記述フォーマットを直接操作するときのような柔軟性は得られない。たとえば、API全体で共有する汎用的なデータ構造を定義する場合、さまざまなコンテキストに合わせて例を提供することは不可能である。  
・コードにドキュメントを埋め込むと、ドキュメントを修正するために実質的にコードを変更することになる。誰が何（ドキュメントまたはコード）を担当しているのか、そしてコードを修正するときの組織とあなたの信頼度によっては、そのことが問題になりかねない。  
・世界中のすべての組織が、コミットされたアプリケーションを何の迷いもなく本番稼働環境に自動的にプッシュできるわけではない。   
・ドキュメントを生成するために早い段階からコードを実際に書かなければならない。本書の最初のほうで述べたように、このようにするとプロバイダの視点が露呈することがある。

- ↑を全部考えられてなかったな。。FastAPI使ってるけど、どこまでできるかをちゃんと見るか。。

> 進化と終了を文書化する

- deprecatedもちゃんと書いていかなきゃな

### 第13章 APIを成長させる

> APIのライフサイクルを成功させるためには、設計者がステークホルダー、プロダクトオーナー、テクニカルライター、開発者やテスト技術者と
緊密に協力しなければならない。

- なるべく広く意見をもらいたい

> 組織／チームのAPIの内外で一貫性を確保するには、ガイドラインの定義
が不可欠である

- はじめにガイドライン作ったけどほんとに正解だったな。。

> APIの設計ガイドラインは、次の3種類のレイヤで構成できる。  
・リファレンスガイドライン：設計の基本的な要素を説明することに焦点を合わせている。  
・ユースケースガイドライン：さまざまなユースケースを使って基本的な要素をどのように適用するのかを説明する。  
・設計プロセスガイドライン：APIの設計方法に関するガイダンスを提供する。

- この書き方はできてなかったので勉強になる
- あらゆるガイドラインで適用できそう
